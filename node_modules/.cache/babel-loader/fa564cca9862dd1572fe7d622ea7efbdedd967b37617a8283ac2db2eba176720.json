{"ast":null,"code":"// src/index.ts\nimport Select from \"react-select\";\n\n// src/useAsyncPaginate.ts\nimport { useState as useState2, useCallback as useCallback2 } from \"react\";\n\n// src/useAsyncPaginateBase.ts\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport useIsMountedRef from \"use-is-mounted-ref\";\nimport { useLazyRef } from \"@vtaits/use-lazy-ref\";\n\n// src/getInitialCache.ts\nvar getInitialCache = params => ({\n  isFirstLoad: true,\n  options: [],\n  hasMore: true,\n  isLoading: false,\n  additional: params.additional\n});\n\n// src/getInitialOptionsCache.ts\nvar getInitialOptionsCache = _ref => {\n  let {\n    options,\n    defaultOptions,\n    additional,\n    defaultAdditional\n  } = _ref;\n  const initialOptions = defaultOptions === true ? null : defaultOptions instanceof Array ? defaultOptions : options;\n  if (initialOptions) {\n    return {\n      \"\": {\n        isFirstLoad: false,\n        isLoading: false,\n        options: initialOptions,\n        hasMore: true,\n        additional: defaultAdditional || additional\n      }\n    };\n  }\n  return {};\n};\n\n// src/defaultShouldLoadMore.ts\nvar AVAILABLE_DELTA = 10;\nvar defaultShouldLoadMore = (scrollHeight, clientHeight, scrollTop) => {\n  const bottomBorder = scrollHeight - clientHeight - AVAILABLE_DELTA;\n  return bottomBorder < scrollTop;\n};\n\n// src/defaultReduceOptions.ts\nvar defaultReduceOptions = (prevOptions, loadedOptions) => [...prevOptions, ...loadedOptions];\n\n// src/requestOptions.ts\nimport sleep from \"sleep-promise\";\n\n// src/validateResponse.ts\nvar errorText = '[react-select-async-paginate] response of \"loadOptions\" should be an object with \"options\" prop, which contains array of options.';\nvar checkIsResponse = response => {\n  if (!response) {\n    return false;\n  }\n  const {\n    options,\n    hasMore\n  } = response;\n  if (!Array.isArray(options)) {\n    return false;\n  }\n  if (typeof hasMore !== \"boolean\" && typeof hasMore !== \"undefined\") {\n    return false;\n  }\n  return true;\n};\nvar validateResponse = response => {\n  if (!checkIsResponse(response)) {\n    console.error(errorText, \"Received:\", response);\n    throw new Error(errorText);\n  }\n  return true;\n};\n\n// src/requestOptions.ts\nvar requestOptions = async (caller, paramsRef, optionsCacheRef, debounceTimeout, setOptionsCache, reduceOptions) => {\n  const currentInputValue = paramsRef.current.inputValue;\n  const isCacheEmpty = !optionsCacheRef.current[currentInputValue];\n  const currentOptions = isCacheEmpty ? getInitialCache(paramsRef.current) : optionsCacheRef.current[currentInputValue];\n  if (currentOptions.isLoading || !currentOptions.hasMore) {\n    return;\n  }\n  setOptionsCache(prevOptionsCache => ({\n    ...prevOptionsCache,\n    [currentInputValue]: {\n      ...currentOptions,\n      isLoading: true\n    }\n  }));\n  if (debounceTimeout > 0 && caller === \"input-change\") {\n    await sleep(debounceTimeout);\n    const newInputValue = paramsRef.current.inputValue;\n    if (currentInputValue !== newInputValue) {\n      setOptionsCache(prevOptionsCache => {\n        if (isCacheEmpty) {\n          const {\n            [currentInputValue]: itemForDelete,\n            ...restCache\n          } = prevOptionsCache;\n          return restCache;\n        }\n        return {\n          ...prevOptionsCache,\n          [currentInputValue]: {\n            ...currentOptions,\n            isLoading: false\n          }\n        };\n      });\n      return;\n    }\n  }\n  let response;\n  let hasError = false;\n  try {\n    const {\n      loadOptions\n    } = paramsRef.current;\n    response = await loadOptions(currentInputValue, currentOptions.options, currentOptions.additional);\n  } catch (e) {\n    hasError = true;\n  }\n  if (hasError) {\n    setOptionsCache(prevOptionsCache => ({\n      ...prevOptionsCache,\n      [currentInputValue]: {\n        ...currentOptions,\n        isLoading: false\n      }\n    }));\n    return;\n  }\n  if (validateResponse(response)) {\n    const {\n      options,\n      hasMore\n    } = response;\n    const newAdditional = response.hasOwnProperty(\"additional\") ? response.additional : currentOptions.additional;\n    setOptionsCache(prevOptionsCache => ({\n      ...prevOptionsCache,\n      [currentInputValue]: {\n        ...currentOptions,\n        options: reduceOptions(currentOptions.options, options, newAdditional),\n        hasMore: !!hasMore,\n        isLoading: false,\n        isFirstLoad: false,\n        additional: newAdditional\n      }\n    }));\n  }\n};\n\n// src/useAsyncPaginateBase.ts\nvar increaseStateId = prevStateId => prevStateId + 1;\nvar useAsyncPaginateBase = function (params) {\n  let deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const {\n    defaultOptions,\n    loadOptionsOnMenuOpen = true,\n    debounceTimeout = 0,\n    inputValue,\n    menuIsOpen,\n    filterOption = null,\n    reduceOptions = defaultReduceOptions,\n    shouldLoadMore = defaultShouldLoadMore\n  } = params;\n  const isMountedRef = useIsMountedRef();\n  const isInitRef = useRef(true);\n  const paramsRef = useRef(params);\n  paramsRef.current = params;\n  const setStateId = useState(0)[1];\n  const optionsCacheRef = useLazyRef(() => getInitialOptionsCache(params));\n  const callRequestOptions = useCallback(caller => {\n    requestOptions(caller, paramsRef, optionsCacheRef, debounceTimeout, reduceState => {\n      optionsCacheRef.current = reduceState(optionsCacheRef.current);\n      if (isMountedRef.current) {\n        setStateId(increaseStateId);\n      }\n    }, reduceOptions);\n  }, [debounceTimeout]);\n  const handleScrolledToBottom = useCallback(() => {\n    const currentInputValue = paramsRef.current.inputValue;\n    const currentOptions2 = optionsCacheRef.current[currentInputValue];\n    if (currentOptions2) {\n      callRequestOptions(\"menu-scroll\");\n    }\n  }, [callRequestOptions]);\n  useEffect(() => {\n    if (isInitRef.current) {\n      isInitRef.current = false;\n    } else {\n      optionsCacheRef.current = {};\n      setStateId(increaseStateId);\n    }\n    if (defaultOptions === true) {\n      callRequestOptions(\"autoload\");\n    }\n  }, deps);\n  useEffect(() => {\n    if (menuIsOpen && !optionsCacheRef.current[inputValue]) {\n      callRequestOptions(\"input-change\");\n    }\n  }, [inputValue]);\n  useEffect(() => {\n    if (menuIsOpen && !optionsCacheRef.current[\"\"] && loadOptionsOnMenuOpen) {\n      callRequestOptions(\"menu-toggle\");\n    }\n  }, [menuIsOpen]);\n  const currentOptions = optionsCacheRef.current[inputValue] || getInitialCache(params);\n  return {\n    handleScrolledToBottom,\n    shouldLoadMore,\n    filterOption,\n    isLoading: currentOptions.isLoading,\n    isFirstLoad: currentOptions.isFirstLoad,\n    options: currentOptions.options\n  };\n};\n\n// src/useAsyncPaginate.ts\nvar useAsyncPaginate = function (params) {\n  let deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const {\n    inputValue: inputValueParam,\n    menuIsOpen: menuIsOpenParam,\n    defaultInputValue: defaultInputValueParam,\n    defaultMenuIsOpen: defaultMenuIsOpenParam,\n    onInputChange: onInputChangeParam,\n    onMenuClose: onMenuCloseParam,\n    onMenuOpen: onMenuOpenParam\n  } = params;\n  const [inputValueState, setInputValue] = useState2(defaultInputValueParam || \"\");\n  const [menuIsOpenState, setMenuIsOpen] = useState2(!!defaultMenuIsOpenParam);\n  const inputValue = typeof inputValueParam === \"string\" ? inputValueParam : inputValueState;\n  const menuIsOpen = typeof menuIsOpenParam === \"boolean\" ? menuIsOpenParam : menuIsOpenState;\n  const onInputChange = useCallback2((nextInputValue, actionMeta) => {\n    if (onInputChangeParam) {\n      onInputChangeParam(nextInputValue, actionMeta);\n    }\n    setInputValue(nextInputValue);\n  }, [onInputChangeParam]);\n  const onMenuClose = useCallback2(() => {\n    if (onMenuCloseParam) {\n      onMenuCloseParam();\n    }\n    setMenuIsOpen(false);\n  }, [onMenuCloseParam]);\n  const onMenuOpen = useCallback2(() => {\n    if (onMenuOpenParam) {\n      onMenuOpenParam();\n    }\n    setMenuIsOpen(true);\n  }, [onMenuOpenParam]);\n  const baseResult = useAsyncPaginateBase({\n    ...params,\n    inputValue,\n    menuIsOpen\n  }, deps);\n  return {\n    ...baseResult,\n    inputValue,\n    menuIsOpen,\n    onInputChange,\n    onMenuClose,\n    onMenuOpen\n  };\n};\n\n// src/useComponents.ts\nimport { useMemo } from \"react\";\nimport { components as defaultComponents } from \"react-select\";\n\n// src/wrapMenuList.tsx\nimport { useEffect as useEffect2, useRef as useRef2, useCallback as useCallback3 } from \"react\";\nimport composeRefs from \"@seznam/compose-react-refs\";\nimport { jsx } from \"react/jsx-runtime\";\nvar CHECK_TIMEOUT = 300;\nfunction wrapMenuList(MenuList2) {\n  function WrappedMenuList(props) {\n    const {\n      selectProps,\n      innerRef\n    } = props;\n    const {\n      handleScrolledToBottom,\n      shouldLoadMore\n    } = selectProps;\n    const checkTimeoutRef = useRef2();\n    const menuListRef = useRef2(null);\n    const shouldHandle = useCallback3(() => {\n      const el = menuListRef.current;\n      if (!el) {\n        return false;\n      }\n      const {\n        scrollTop,\n        scrollHeight,\n        clientHeight\n      } = el;\n      return shouldLoadMore(scrollHeight, clientHeight, scrollTop);\n    }, [shouldLoadMore]);\n    const checkAndHandle = useCallback3(() => {\n      if (shouldHandle()) {\n        if (handleScrolledToBottom) {\n          handleScrolledToBottom();\n        }\n      }\n    }, [shouldHandle, handleScrolledToBottom]);\n    const setCheckAndHandleTimeout = useCallback3(() => {\n      checkAndHandle();\n      checkTimeoutRef.current = setTimeout(setCheckAndHandleTimeout, CHECK_TIMEOUT);\n    }, [checkAndHandle]);\n    useEffect2(() => {\n      setCheckAndHandleTimeout();\n      return () => {\n        if (checkTimeoutRef.current) {\n          clearTimeout(checkTimeoutRef.current);\n        }\n      };\n    }, []);\n    return /* @__PURE__ */jsx(MenuList2, {\n      ...props,\n      innerRef: composeRefs(innerRef, menuListRef)\n    });\n  }\n  return WrappedMenuList;\n}\n\n// src/useComponents.ts\nvar MenuList = wrapMenuList(defaultComponents.MenuList);\nvar useComponents = components => useMemo(() => ({\n  MenuList,\n  ...components\n}), [components]);\n\n// src/withAsyncPaginate.tsx\nimport { jsx as jsx2 } from \"react/jsx-runtime\";\nfunction withAsyncPaginate(SelectComponent) {\n  function WithAsyncPaginate(props) {\n    const {\n      components,\n      selectRef,\n      isLoading: isLoadingProp,\n      cacheUniqs,\n      ...rest\n    } = props;\n    const asyncPaginateProps = useAsyncPaginate(rest, cacheUniqs);\n    const processedComponents = useComponents(components);\n    const isLoading = typeof isLoadingProp === \"boolean\" ? isLoadingProp : asyncPaginateProps.isLoading;\n    return /* @__PURE__ */jsx2(SelectComponent, {\n      ...props,\n      ...asyncPaginateProps,\n      isLoading,\n      components: processedComponents,\n      ref: selectRef\n    });\n  }\n  WithAsyncPaginate.defaultProps = {\n    selectRef: null,\n    cacheUniqs: [],\n    components: {}\n  };\n  return WithAsyncPaginate;\n}\n\n// src/reduceGroupedOptions.ts\nvar checkGroup = group => {\n  if (!group) {\n    return false;\n  }\n  const {\n    label,\n    options\n  } = group;\n  if (typeof label !== \"string\" && typeof label !== \"undefined\") {\n    return false;\n  }\n  if (!Array.isArray(options)) {\n    return false;\n  }\n  return true;\n};\nvar reduceGroupedOptions = (prevOptions, loadedOptions) => {\n  const res = prevOptions.slice();\n  const mapLabelToIndex = {};\n  let prevOptionsIndex = 0;\n  const prevOptionsLength = prevOptions.length;\n  loadedOptions.forEach(optionOrGroup => {\n    const group = checkGroup(optionOrGroup) ? optionOrGroup : {\n      options: [optionOrGroup]\n    };\n    const {\n      label = \"\"\n    } = group;\n    let groupIndex = mapLabelToIndex[label];\n    if (typeof groupIndex !== \"number\") {\n      for (; prevOptionsIndex < prevOptionsLength && typeof mapLabelToIndex[label] !== \"number\"; ++prevOptionsIndex) {\n        const prevGroup = prevOptions[prevOptionsIndex];\n        if (checkGroup(prevGroup)) {\n          mapLabelToIndex[prevGroup.label || \"\"] = prevOptionsIndex;\n        }\n      }\n      groupIndex = mapLabelToIndex[label];\n    }\n    if (typeof groupIndex !== \"number\") {\n      mapLabelToIndex[label] = res.length;\n      res.push(group);\n      return;\n    }\n    res[groupIndex] = {\n      ...res[groupIndex],\n      options: [...res[groupIndex].options, ...group.options]\n    };\n  });\n  return res;\n};\n\n// src/index.ts\nvar AsyncPaginate = withAsyncPaginate(Select);\nexport { AsyncPaginate, checkIsResponse, reduceGroupedOptions, useAsyncPaginate, useAsyncPaginateBase, useComponents, validateResponse, withAsyncPaginate, wrapMenuList };","map":{"version":3,"mappings":"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","names":["Select","useState","useCallback","useEffect","useRef","useIsMountedRef","useLazyRef","getInitialCache","params","isFirstLoad","options","hasMore","isLoading","additional","getInitialOptionsCache","defaultOptions","defaultAdditional","initialOptions","Array","AVAILABLE_DELTA","defaultShouldLoadMore","scrollHeight","clientHeight","scrollTop","bottomBorder","defaultReduceOptions","prevOptions","loadedOptions","sleep","errorText","checkIsResponse","response","isArray","validateResponse","console","error","Error","requestOptions","caller","paramsRef","optionsCacheRef","debounceTimeout","setOptionsCache","reduceOptions","currentInputValue","current","inputValue","isCacheEmpty","currentOptions","prevOptionsCache","newInputValue","itemForDelete","restCache","hasError","loadOptions","e","newAdditional","hasOwnProperty","increaseStateId","prevStateId","useAsyncPaginateBase","deps","loadOptionsOnMenuOpen","menuIsOpen","filterOption","shouldLoadMore","isMountedRef","isInitRef","setStateId","callRequestOptions","reduceState","handleScrolledToBottom","useAsyncPaginate","inputValueParam","menuIsOpenParam","defaultInputValue","defaultInputValueParam","defaultMenuIsOpen","defaultMenuIsOpenParam","onInputChange","onInputChangeParam","onMenuClose","onMenuCloseParam","onMenuOpen","onMenuOpenParam","inputValueState","setInputValue","menuIsOpenState","setMenuIsOpen","nextInputValue","actionMeta","baseResult","useMemo","components","defaultComponents","composeRefs","CHECK_TIMEOUT","wrapMenuList","MenuList","WrappedMenuList","props","selectProps","innerRef","checkTimeoutRef","menuListRef","shouldHandle","el","checkAndHandle","setCheckAndHandleTimeout","setTimeout","clearTimeout","useComponents","withAsyncPaginate","SelectComponent","WithAsyncPaginate","selectRef","isLoadingProp","cacheUniqs","rest","asyncPaginateProps","processedComponents","ref","defaultProps","checkGroup","group","label","reduceGroupedOptions","res","slice","mapLabelToIndex","prevOptionsIndex","prevOptionsLength","length","forEach","optionOrGroup","groupIndex","prevGroup","push","AsyncPaginate"],"sources":["/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/index.ts","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/useAsyncPaginate.ts","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/useAsyncPaginateBase.ts","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/getInitialCache.ts","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/getInitialOptionsCache.ts","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/defaultShouldLoadMore.ts","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/defaultReduceOptions.ts","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/requestOptions.ts","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/validateResponse.ts","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/useComponents.ts","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/wrapMenuList.tsx","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/withAsyncPaginate.tsx","/Users/harishmohan/Desktop/webdroilocal/node_modules/react-select-async-paginate/src/reduceGroupedOptions.ts"],"sourcesContent":["import Select from 'react-select';\n\nimport { withAsyncPaginate } from './withAsyncPaginate';\n\nexport { wrapMenuList } from './wrapMenuList';\nexport { reduceGroupedOptions } from './reduceGroupedOptions';\n\nexport { withAsyncPaginate };\n\nexport {\n  checkIsResponse,\n  validateResponse,\n} from './validateResponse';\nexport { useAsyncPaginateBase } from './useAsyncPaginateBase';\nexport { useAsyncPaginate } from './useAsyncPaginate';\nexport { useComponents } from './useComponents';\n\nexport const AsyncPaginate = withAsyncPaginate(Select);\n\nexport * from './types';\n","import {\n  useState,\n  useCallback,\n} from 'react';\nimport type {\n  GroupBase,\n  InputActionMeta,\n} from 'react-select';\n\nimport {\n  useAsyncPaginateBase,\n} from './useAsyncPaginateBase';\n\nimport type {\n  UseAsyncPaginateParams,\n  UseAsyncPaginateBaseResult,\n  UseAsyncPaginateResult,\n} from './types';\n\nexport const useAsyncPaginate = <OptionType, Group extends GroupBase<OptionType>, Additional>(\n  params: UseAsyncPaginateParams<OptionType, Group, Additional>,\n  deps: ReadonlyArray<unknown> = [],\n): UseAsyncPaginateResult<OptionType, Group> => {\n  const {\n    inputValue: inputValueParam,\n    menuIsOpen: menuIsOpenParam,\n    defaultInputValue: defaultInputValueParam,\n    defaultMenuIsOpen: defaultMenuIsOpenParam,\n    onInputChange: onInputChangeParam,\n    onMenuClose: onMenuCloseParam,\n    onMenuOpen: onMenuOpenParam,\n  } = params;\n\n  const [inputValueState, setInputValue] = useState(\n    defaultInputValueParam || '',\n  );\n  const [menuIsOpenState, setMenuIsOpen] = useState(\n    !!defaultMenuIsOpenParam,\n  );\n\n  const inputValue: string = typeof inputValueParam === 'string'\n    ? inputValueParam\n    : inputValueState;\n\n  const menuIsOpen: boolean = typeof menuIsOpenParam === 'boolean'\n    ? menuIsOpenParam\n    : menuIsOpenState;\n\n  const onInputChange = useCallback((\n    nextInputValue: string,\n    actionMeta: InputActionMeta,\n  ): void => {\n    if (onInputChangeParam) {\n      onInputChangeParam(nextInputValue, actionMeta);\n    }\n\n    setInputValue(nextInputValue);\n  }, [onInputChangeParam]);\n\n  const onMenuClose = useCallback((): void => {\n    if (onMenuCloseParam) {\n      onMenuCloseParam();\n    }\n\n    setMenuIsOpen(false);\n  }, [onMenuCloseParam]);\n\n  const onMenuOpen = useCallback((): void => {\n    if (onMenuOpenParam) {\n      onMenuOpenParam();\n    }\n\n    setMenuIsOpen(true);\n  }, [onMenuOpenParam]);\n\n  const baseResult: UseAsyncPaginateBaseResult<OptionType, Group> = useAsyncPaginateBase(\n    {\n      ...params,\n      inputValue,\n      menuIsOpen,\n    },\n    deps,\n  );\n\n  return {\n    ...baseResult,\n    inputValue,\n    menuIsOpen,\n    onInputChange,\n    onMenuClose,\n    onMenuOpen,\n  };\n};\n","import {\n  useState,\n  useEffect,\n  useRef,\n  useCallback,\n} from 'react';\n\nimport type {\n  GroupBase,\n} from 'react-select';\n\nimport useIsMountedRef from 'use-is-mounted-ref';\n\nimport { useLazyRef } from '@vtaits/use-lazy-ref';\n\nimport { getInitialCache } from './getInitialCache';\nimport { getInitialOptionsCache } from './getInitialOptionsCache';\nimport { defaultShouldLoadMore } from './defaultShouldLoadMore';\nimport { defaultReduceOptions } from './defaultReduceOptions';\nimport { requestOptions } from './requestOptions';\n\nimport type {\n  OptionsCacheItem,\n  UseAsyncPaginateBaseResult,\n  UseAsyncPaginateBaseParams,\n  RequestOptionsCallerType,\n} from './types';\n\nexport const increaseStateId = (prevStateId: number): number => prevStateId + 1;\n\nexport const useAsyncPaginateBase = <\nOptionType,\nGroup extends GroupBase<OptionType>,\nAdditional,\n  >(\n    params: UseAsyncPaginateBaseParams<OptionType, Group, Additional>,\n    deps: ReadonlyArray<any> = [],\n  ): UseAsyncPaginateBaseResult<OptionType, Group> => {\n  const {\n    defaultOptions,\n    loadOptionsOnMenuOpen = true,\n    debounceTimeout = 0,\n    inputValue,\n    menuIsOpen,\n    filterOption = null,\n    reduceOptions = defaultReduceOptions,\n    shouldLoadMore = defaultShouldLoadMore,\n  } = params;\n\n  const isMountedRef = useIsMountedRef();\n\n  const isInitRef = useRef<boolean>(true);\n  const paramsRef = useRef<UseAsyncPaginateBaseParams<OptionType, Group, Additional>>(params);\n\n  paramsRef.current = params;\n\n  const setStateId = useState(0)[1];\n\n  const optionsCacheRef = useLazyRef(() => getInitialOptionsCache(params));\n\n  const callRequestOptions = useCallback((caller: RequestOptionsCallerType): void => {\n    requestOptions(\n      caller,\n      paramsRef,\n      optionsCacheRef,\n      debounceTimeout,\n      (reduceState) => {\n        optionsCacheRef.current = reduceState(optionsCacheRef.current);\n\n        if (isMountedRef.current) {\n          setStateId(increaseStateId);\n        }\n      },\n      reduceOptions,\n    );\n  }, [debounceTimeout]);\n\n  const handleScrolledToBottom = useCallback((): void => {\n    const currentInputValue = paramsRef.current.inputValue;\n    const currentOptions = optionsCacheRef.current[currentInputValue];\n\n    if (currentOptions) {\n      callRequestOptions('menu-scroll');\n    }\n  }, [callRequestOptions]);\n\n  useEffect(() => {\n    if (isInitRef.current) {\n      isInitRef.current = false;\n    } else {\n      optionsCacheRef.current = {};\n      setStateId(increaseStateId);\n    }\n\n    if (defaultOptions === true) {\n      callRequestOptions('autoload');\n    }\n  }, deps);\n\n  useEffect(() => {\n    if (menuIsOpen && !optionsCacheRef.current[inputValue]) {\n      callRequestOptions('input-change');\n    }\n  }, [inputValue]);\n\n  useEffect(() => {\n    if (\n      menuIsOpen\n      && !optionsCacheRef.current['']\n      && loadOptionsOnMenuOpen\n    ) {\n      callRequestOptions('menu-toggle');\n    }\n  }, [menuIsOpen]);\n\n  const currentOptions: OptionsCacheItem<\n  OptionType,\n  Group,\n  Additional\n  > = optionsCacheRef.current[inputValue]\n    || getInitialCache(params);\n\n  return {\n    handleScrolledToBottom,\n    shouldLoadMore,\n    filterOption,\n    isLoading: currentOptions.isLoading,\n    isFirstLoad: currentOptions.isFirstLoad,\n    options: currentOptions.options,\n  };\n};\n","import type {\n  GroupBase,\n} from 'react-select';\n\nimport type {\n  OptionsCacheItem,\n  UseAsyncPaginateBaseParams,\n} from './types';\n\nexport const getInitialCache = <OptionType, Group extends GroupBase<OptionType>, Additional>(\n  params: UseAsyncPaginateBaseParams<OptionType, Group, Additional>,\n): OptionsCacheItem<OptionType, Group, Additional> => ({\n    isFirstLoad: true,\n    options: [],\n    hasMore: true,\n    isLoading: false,\n    additional: params.additional,\n  });\n","import type {\n  GroupBase,\n} from 'react-select';\n\nimport type {\n  OptionsCache,\n  UseAsyncPaginateBaseParams,\n} from './types';\n\nexport const getInitialOptionsCache = <\nOptionType,\nGroup extends GroupBase<OptionType>,\nAdditional>(\n    {\n      options,\n      defaultOptions,\n      additional,\n      defaultAdditional,\n    }: UseAsyncPaginateBaseParams<OptionType, Group, Additional>,\n  ): OptionsCache<OptionType, Group, Additional> => {\n  const initialOptions = defaultOptions === true\n    ? null\n    : (defaultOptions instanceof Array)\n      ? defaultOptions\n      : options;\n\n  if (initialOptions) {\n    return {\n      '': {\n        isFirstLoad: false,\n        isLoading: false,\n        options: initialOptions,\n        hasMore: true,\n        additional: defaultAdditional || additional,\n      },\n    };\n  }\n\n  return {};\n};\n","import type {\n  ShouldLoadMore,\n} from './types';\n\nconst AVAILABLE_DELTA = 10;\n\nexport const defaultShouldLoadMore: ShouldLoadMore = (scrollHeight, clientHeight, scrollTop) => {\n  const bottomBorder = scrollHeight - clientHeight - AVAILABLE_DELTA;\n\n  return bottomBorder < scrollTop;\n};\n","import type {\n  GroupBase,\n  OptionsOrGroups,\n} from 'react-select';\n\nexport const defaultReduceOptions = <OptionType, Group extends GroupBase<OptionType>>(\n  prevOptions: OptionsOrGroups<OptionType, Group>,\n  loadedOptions: OptionsOrGroups<OptionType, Group>,\n) => [...prevOptions, ...loadedOptions];\n","import type {\n  MutableRefObject,\n} from 'react';\n\nimport type {\n  GroupBase,\n} from 'react-select';\nimport sleep from 'sleep-promise';\n\nimport { getInitialCache } from './getInitialCache';\nimport { validateResponse } from './validateResponse';\n\nimport type {\n  OptionsCache,\n  OptionsCacheItem,\n  UseAsyncPaginateBaseParams,\n  ReduceOptions,\n  RequestOptionsCallerType,\n} from './types';\n\ntype MapOptionsCache<OptionType, Group extends GroupBase<OptionType>, Additional> = (\n  prevCache: OptionsCache<OptionType, Group, Additional>,\n) => OptionsCache<OptionType, Group, Additional>;\n\ntype SetOptionsCache<OptionType, Group extends GroupBase<OptionType>, Additional> = (\n  stateMapper: MapOptionsCache<OptionType, Group, Additional>,\n) => void;\n\nexport const requestOptions = async <OptionType, Group extends GroupBase<OptionType>, Additional>(\n  caller: RequestOptionsCallerType,\n  paramsRef: MutableRefObject<UseAsyncPaginateBaseParams<OptionType, Group, Additional>>,\n  optionsCacheRef: MutableRefObject<OptionsCache<OptionType, Group, Additional>>,\n  debounceTimeout: number,\n  setOptionsCache: SetOptionsCache<OptionType, Group, Additional>,\n  reduceOptions: ReduceOptions<OptionType, Group, Additional>,\n): Promise<void> => {\n  const currentInputValue = paramsRef.current.inputValue;\n\n  const isCacheEmpty = !optionsCacheRef.current[currentInputValue];\n\n  const currentOptions: OptionsCacheItem<OptionType, Group, Additional> = isCacheEmpty\n    ? getInitialCache(paramsRef.current)\n    : optionsCacheRef.current[currentInputValue];\n\n  if (currentOptions.isLoading || !currentOptions.hasMore) {\n    return;\n  }\n\n  setOptionsCache((\n    prevOptionsCache: OptionsCache<OptionType, Group, Additional>,\n  ): OptionsCache<OptionType, Group, Additional> => ({\n    ...prevOptionsCache,\n    [currentInputValue]: {\n      ...currentOptions,\n      isLoading: true,\n    },\n  }));\n\n  if (debounceTimeout > 0 && caller === 'input-change') {\n    await sleep(debounceTimeout);\n\n    const newInputValue = paramsRef.current.inputValue;\n\n    if (currentInputValue !== newInputValue) {\n      setOptionsCache((prevOptionsCache) => {\n        if (isCacheEmpty) {\n          const {\n            [currentInputValue]: itemForDelete,\n            ...restCache\n          } = prevOptionsCache;\n\n          return restCache;\n        }\n\n        return {\n          ...prevOptionsCache,\n          [currentInputValue]: {\n            ...currentOptions,\n            isLoading: false,\n          },\n        };\n      });\n\n      return;\n    }\n  }\n\n  let response;\n  let hasError = false;\n\n  try {\n    const {\n      loadOptions,\n    } = paramsRef.current;\n\n    response = await loadOptions(\n      currentInputValue,\n      currentOptions.options,\n      currentOptions.additional,\n    );\n  } catch (e) {\n    hasError = true;\n  }\n\n  if (hasError) {\n    setOptionsCache((prevOptionsCache) => ({\n      ...prevOptionsCache,\n      [currentInputValue]: {\n        ...currentOptions,\n        isLoading: false,\n      },\n    }));\n\n    return;\n  }\n\n  if (validateResponse(response)) {\n    const {\n      options,\n      hasMore,\n    } = response;\n\n    // eslint-disable-next-line no-prototype-builtins\n    const newAdditional = response.hasOwnProperty('additional')\n      ? response.additional\n      : currentOptions.additional;\n\n    setOptionsCache((prevOptionsCache) => ({\n      ...prevOptionsCache,\n      [currentInputValue]: {\n        ...currentOptions,\n        options: reduceOptions(currentOptions.options, options, newAdditional),\n        hasMore: !!hasMore,\n        isLoading: false,\n        isFirstLoad: false,\n        additional: newAdditional,\n      },\n    }));\n  }\n};\n","import type {\n  GroupBase,\n} from 'react-select';\n\nimport type {\n  Response,\n} from './types';\n\nexport const errorText = '[react-select-async-paginate] response of \"loadOptions\" should be an object with \"options\" prop, which contains array of options.';\n\nexport const checkIsResponse = <OptionType, Group extends GroupBase<OptionType>, Additional>(\n  response: unknown,\n): response is Response<OptionType, Group, Additional> => {\n  if (!response) {\n    return false;\n  }\n\n  const {\n    options,\n    hasMore,\n  } = response as {\n    options?: unknown;\n    hasMore?: unknown;\n  };\n\n  if (!Array.isArray(options)) {\n    return false;\n  }\n\n  if (typeof hasMore !== 'boolean' && typeof hasMore !== 'undefined') {\n    return false;\n  }\n\n  return true;\n};\n\nexport const validateResponse = <OptionType, Group extends GroupBase<OptionType>, Additional>(\n  response: unknown,\n): response is Response<OptionType, Group, Additional> => {\n  if (!checkIsResponse(response)) {\n    // eslint-disable-next-line no-console\n    console.error(errorText, 'Received:', response);\n    throw new Error(errorText);\n  }\n\n  return true;\n};\n","import {\n  useMemo,\n} from 'react';\nimport type {\n  GroupBase,\n  Props as SelectProps,\n} from 'react-select';\n\nimport { components as defaultComponents } from 'react-select';\n\nimport { wrapMenuList } from './wrapMenuList';\n\nexport const MenuList = wrapMenuList(defaultComponents.MenuList);\n\nexport type SelectComponentsConfig<\nOptionType,\nIsMulti extends boolean,\nGroup extends GroupBase<OptionType>,\n> = Partial<SelectProps<OptionType, IsMulti, Group>['components']>;\n\nexport const useComponents = <\nOptionType,\nGroup extends GroupBase<OptionType>,\nIsMulti extends boolean,\n>(\n    components: SelectComponentsConfig<OptionType, IsMulti, Group>,\n  ): SelectComponentsConfig<OptionType, IsMulti, Group> => useMemo(() => ({\n    MenuList,\n    ...components,\n  }), [components]);\n","import {\n  useEffect,\n  useRef,\n  useCallback,\n} from 'react';\nimport type {\n  ReactElement,\n} from 'react';\n\nimport type {\n  GroupBase,\n  MenuListProps,\n} from 'react-select';\n\nimport composeRefs from '@seznam/compose-react-refs';\n\nimport type {\n  ShouldLoadMore,\n} from './types';\n\nexport const CHECK_TIMEOUT = 300;\n\nexport type BaseSelectProps = {\n  handleScrolledToBottom?: () => void;\n  shouldLoadMore: ShouldLoadMore;\n};\n\ntype MenuListType <\nOption = unknown,\nIsMulti extends boolean = boolean,\nGroup extends GroupBase<Option> = GroupBase<Option>,\n> = (props: MenuListProps<Option, IsMulti, Group>) => ReactElement;\n\nexport function wrapMenuList<\nOption = unknown,\nIsMulti extends boolean = boolean,\nGroup extends GroupBase<Option> = GroupBase<Option>,\n>(\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  MenuList: MenuListType<Option, IsMulti, Group>,\n) {\n  function WrappedMenuList(props: MenuListProps<Option, IsMulti, Group>) {\n    const {\n      selectProps,\n      innerRef,\n    } = props;\n\n    const {\n      handleScrolledToBottom,\n      shouldLoadMore,\n    } = selectProps as unknown as BaseSelectProps;\n\n    const checkTimeoutRef = useRef<NodeJS.Timeout>();\n    const menuListRef = useRef<HTMLElement>(null);\n\n    const shouldHandle = useCallback(() => {\n      const el = menuListRef.current;\n\n      // menu is not rendered\n      if (!el) {\n        return false;\n      }\n\n      const {\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n      } = el;\n\n      return shouldLoadMore(scrollHeight, clientHeight, scrollTop);\n    }, [shouldLoadMore]);\n\n    const checkAndHandle = useCallback(() => {\n      if (shouldHandle()) {\n        if (handleScrolledToBottom) {\n          handleScrolledToBottom();\n        }\n      }\n    }, [shouldHandle, handleScrolledToBottom]);\n\n    const setCheckAndHandleTimeout = useCallback(() => {\n      checkAndHandle();\n\n      checkTimeoutRef.current = setTimeout(setCheckAndHandleTimeout, CHECK_TIMEOUT);\n    }, [checkAndHandle]);\n\n    useEffect(() => {\n      setCheckAndHandleTimeout();\n\n      return (): void => {\n        if (checkTimeoutRef.current) {\n          clearTimeout(checkTimeoutRef.current);\n        }\n      };\n    }, []);\n\n    return (\n      <MenuList\n        {...props}\n        innerRef={composeRefs<HTMLElement>(innerRef, menuListRef)}\n      />\n    );\n  }\n\n  return WrappedMenuList;\n}\n","import type {\n  Ref,\n  ReactElement,\n} from 'react';\nimport type {\n  GroupBase,\n  Props as SelectProps,\n  SelectInstance,\n} from 'react-select';\n\nimport {\n  useAsyncPaginate,\n} from './useAsyncPaginate';\nimport {\n  useComponents,\n} from './useComponents';\n\nimport type {\n  UseAsyncPaginateResult,\n  AsyncPaginateProps,\n  WithAsyncPaginateType,\n} from './types';\n\ntype SelectComponentType = <\nOption = unknown,\nIsMulti extends boolean = boolean,\nGroup extends GroupBase<Option> = GroupBase<Option>,\n>(props: SelectProps<Option, IsMulti, Group> & {\n  ref?: Ref<SelectInstance<Option, IsMulti, Group>>;\n}) => ReactElement;\n\nexport function withAsyncPaginate(\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  SelectComponent: SelectComponentType,\n): WithAsyncPaginateType {\n  function WithAsyncPaginate<\n  OptionType,\n  Group extends GroupBase<OptionType>,\n  Additional,\n  IsMulti extends boolean = false,\n  >(props: AsyncPaginateProps<OptionType, Group, Additional, IsMulti>): ReactElement {\n    const {\n      components,\n      selectRef,\n      isLoading: isLoadingProp,\n      cacheUniqs,\n      ...rest\n    } = props;\n\n    const asyncPaginateProps: UseAsyncPaginateResult<OptionType, Group> = useAsyncPaginate(\n      rest,\n      cacheUniqs,\n    );\n\n    const processedComponents = useComponents<OptionType, Group, IsMulti>(components);\n\n    const isLoading = typeof isLoadingProp === 'boolean'\n      ? isLoadingProp\n      : asyncPaginateProps.isLoading;\n\n    return (\n      <SelectComponent\n        {...props}\n        {...asyncPaginateProps}\n        isLoading={isLoading}\n        components={processedComponents}\n        ref={selectRef}\n      />\n    );\n  }\n\n  WithAsyncPaginate.defaultProps = {\n    selectRef: null,\n    cacheUniqs: [],\n    components: {},\n  };\n\n  return WithAsyncPaginate;\n}\n","import type {\n  GroupBase,\n  OptionsOrGroups,\n} from 'react-select';\n\nexport const checkGroup = (group: unknown): group is GroupBase<unknown> => {\n  if (!group) {\n    return false;\n  }\n\n  const {\n    label,\n    options,\n  } = group as {\n    label?: unknown;\n    options?: unknown;\n  };\n\n  if (typeof label !== 'string' && typeof label !== 'undefined') {\n    return false;\n  }\n\n  if (!Array.isArray(options)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport const reduceGroupedOptions = <\nOptionType,\nGroup extends GroupBase<OptionType>,\n>(\n    prevOptions: OptionsOrGroups<OptionType, Group>,\n    loadedOptions: OptionsOrGroups<OptionType, Group>,\n  ): OptionsOrGroups<OptionType, Group> => {\n  const res = prevOptions.slice();\n\n  const mapLabelToIndex: Record<string, number> = {};\n  let prevOptionsIndex = 0;\n  const prevOptionsLength = prevOptions.length;\n\n  loadedOptions.forEach((optionOrGroup) => {\n    const group = checkGroup(optionOrGroup)\n      ? optionOrGroup\n      : {\n        options: [optionOrGroup],\n      } as unknown as Group;\n\n    const {\n      label = '',\n    } = group;\n\n    let groupIndex = mapLabelToIndex[label];\n    if (typeof groupIndex !== 'number') {\n      for (;\n        prevOptionsIndex < prevOptionsLength && typeof mapLabelToIndex[label] !== 'number';\n        ++prevOptionsIndex\n      ) {\n        const prevGroup = prevOptions[prevOptionsIndex];\n\n        if (checkGroup(prevGroup)) {\n          mapLabelToIndex[prevGroup.label || ''] = prevOptionsIndex;\n        }\n      }\n\n      groupIndex = mapLabelToIndex[label];\n    }\n\n    if (typeof groupIndex !== 'number') {\n      mapLabelToIndex[label] = res.length;\n      res.push(group);\n      return;\n    }\n\n    res[groupIndex] = {\n      ...res[groupIndex],\n      options: [...(res[groupIndex] as Group).options, ...group.options],\n    };\n  });\n\n  return res;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}